<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structure Editor | Registrace zaměstnance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .tree-line {
            border-left: 1px solid #cbd5e1;
        }

        .node-row:hover {
            background-color: #f8fafc;
        }

        .node-row.selected {
            background-color: #eff6ff;
            border-left: 4px solid #4f46e5;
        }

        /* Custom scrollbar for better density */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>

<body class="bg-gray-50 text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <div class="flex-none bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center z-10 shadow-sm">
        <div>
            <h1 class="text-xl font-bold text-slate-900">Editor Struktury Formuláře</h1>
            <p class="text-xs text-slate-500">Úprava regzec_structure.json</p>
        </div>
        <div class="flex gap-3">
            <div id="status" class="hidden px-3 py-1 rounded text-xs"></div>

            <button onclick="loadData()"
                class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1.5 rounded shadow-sm text-xs font-medium">
                Načíst
            </button>
            <button onclick="renumberNodes()"
                class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1.5 rounded shadow-sm text-xs font-medium">
                Přečíslovat
            </button>
            <div class="relative">
                <button onclick="document.getElementById('file-merge').click()"
                    class="bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1.5 rounded shadow-sm text-xs font-medium">
                    Sloučit...
                </button>
                <input type="file" id="file-merge" class="hidden" accept=".json" onchange="handleMergeUpload(this)">
            </div>
            <button onclick="exportData()"
                class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1.5 rounded shadow-sm text-xs font-medium">
                Exportovat JSON
            </button>
        </div>
    </div>

    <!-- Main Content (Flex Layout) -->
    <div class="flex-1 flex overflow-hidden">

        <!-- LEFT PANEL: Tree Table (2/3 width) -->
        <div class="w-2/3 flex flex-col border-r border-gray-200 bg-white">
            <div
                class="bg-gray-50 px-4 py-2 text-xs font-semibold text-gray-500 border-b border-gray-200 flex justify-between">
                <span>Struktura formuláře</span>
                <span class="text-gray-400">Kliknutím na řádek zobrazíte detaily</span>
            </div>

            <div class="flex-1 overflow-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50 sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th
                                class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/2">
                                Atribut (Strom)</th>
                            <th class="px-2 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-12"
                                title="Skip (Přeskočit)">S</th>
                            <th class="px-2 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-12"
                                title="New Only (Pouze pro nového)">N</th>
                            <th
                                class="px-2 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/3">
                                Popis (Label)</th>
                            <th
                                class="px-2 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-12">
                                Order</th>
                            <th
                                class="px-2 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-16">
                                Width</th>
                        </tr>
                    </thead>
                    <tbody id="tbody" class="bg-white divide-y divide-gray-100">
                        <!-- Rows rendered here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- RIGHT PANEL: Detail Form (1/3 width) -->
        <div class="w-1/3 bg-gray-50 flex flex-col overflow-auto">
            <div class="bg-white px-4 py-3 border-b border-gray-200 shadow-sm sticky top-0 z-10">
                <h2 class="text-sm font-bold text-gray-900 uppercase tracking-wider">Detail Atributu</h2>
            </div>

            <div id="detail-panel" class="p-6 space-y-6">
                <div class="text-center text-gray-400 py-10">
                    <svg class="mx-auto h-12 w-12 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1"
                            d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" />
                    </svg>
                    <p class="mt-2 text-sm">Vyberte atribut vlevo pro editaci</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let rootData = [];
        let selectedPath = null;
        let enums = {}; // Cache for enums

        // --- DATA LOADING & MERGING ---

        async function loadData() {
            try {
                // Load Enums first
                const resEnums = await fetch('docs/regzec_enums.json');
                if (resEnums.ok) {
                    enums = await resEnums.json();
                }

                // Load Data
                const res = await fetch('regzec_structure.json');
                if (!res.ok) throw new Error('Failed to load file');
                rootData = await res.json();
                render();
                showStatus('Načteno OK (Enums + Data)', 'green');
            } catch (e) {
                showStatus('Chyba: ' + e.message, 'red');
            }
        }

        function handleMergeUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mergeData = JSON.parse(e.target.result);
                    const stats = { updated: 0, moved: 0, added: 0 };

                    // 1. Map existing RootData by ID for reliable moving
                    const idMap = new Map();
                    function buildIdMap(nodes, parentArray) {
                        nodes.forEach(node => {
                            if (node.id) idMap.set(String(node.id), { node, parentArray });
                            if (node.children) buildIdMap(node.children, node.children);
                        });
                    }
                    buildIdMap(rootData, rootData);

                    // 2. Recursive Merge Function (Source-driven)
                    function mergeProcessing(targetArray, sourceNodes) {
                        sourceNodes.forEach(source => {
                            // Find target node
                            let targetInfo = null;
                            if (source.id && idMap.has(String(source.id))) {
                                targetInfo = idMap.get(String(source.id));
                            }

                            let targetNode = targetInfo ? targetInfo.node : null;

                            // Fallback to Key match in ANY parent? No, scope to current targetArray usually?
                            // But if we are restructuring, we might match by Key in old location?
                            // For simplicity/safety, if no ID, we look in current targetArray.
                            if (!targetNode) {
                                targetNode = targetArray.find(n => n.key === source.key);
                            }

                            if (targetNode) {
                                // UPDATE
                                let changed = false;
                                const propsToSync = [
                                    'description', 'label', 'mandatory', 'dat_typ', 'delka',
                                    'p', 'n', 'z', 'vysvetlivky', 'widget', 'order', 'width',
                                    'skip', 'new_only', 'ciselnik', 'default_value', 'content',
                                    'multiple', 'manual_parent', 'id', 'rows'
                                ];

                                propsToSync.forEach(prop => {
                                    if (source[prop] !== undefined && targetNode[prop] !== source[prop]) {
                                        targetNode[prop] = source[prop];
                                        changed = true;
                                    }
                                });

                                // MOVE Strategy
                                // If found by ID, it might be in a different parent
                                if (targetInfo && targetInfo.parentArray !== targetArray) {
                                    const oldIdx = targetInfo.parentArray.indexOf(targetNode);
                                    if (oldIdx > -1) {
                                        targetInfo.parentArray.splice(oldIdx, 1);
                                        targetArray.push(targetNode); // Add to new parent
                                        stats.moved++;
                                        // Update parentRef for children recursion? Not needed, node ref is same.
                                    }
                                } else if (!targetArray.includes(targetNode)) {
                                    // Found by Key elsewhere? Or logical edge case? 
                                    // If found by Key in current array, includes is true.
                                    // If found by ID and parentArray IS targetArray, includes is true.
                                    // This block shouldn't hit unless key-match logic expands.
                                    targetArray.push(targetNode);
                                }

                                if (changed) stats.updated++;

                                // RECURSE
                                if (source.children) {
                                    if (!targetNode.children) targetNode.children = [];
                                    mergeProcessing(targetNode.children, source.children);
                                }

                            } else {
                                // ADD
                                // Destructure children out to avoid shallow copy holding ref to source tree
                                const { children, ...rest } = source;
                                const newNode = { ...rest, children: [] };

                                targetArray.push(newNode);
                                stats.added++;

                                if (source.children) {
                                    mergeProcessing(newNode.children, source.children);
                                }
                            }
                        });
                    }

                    // For root, we treat rootData as the array
                    // Check if mergeData is array or single object
                    const sourceArray = Array.isArray(mergeData) ? mergeData : [mergeData];

                    mergeProcessing(rootData, sourceArray);

                    render();
                    showStatus(`Sloučeno: ${stats.updated} změn, ${stats.moved} přesunů, ${stats.added} nových.`, 'blue');

                } catch (err) {
                    console.error(err);
                    showStatus('Chyba Merge: ' + err.message, 'red');
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        // --- TREE LOGIC ---

        function toggleCollapse(path) {
            const node = findNodeByPath(rootData, path);
            if (node) {
                node._collapsed = !node._collapsed;
                render();
            }
            event.stopPropagation();
        }

        function selectNode(path) {
            selectedPath = path;
            render(); // Re-render tree to highlight
            renderDetail(path); // Render detail panel
        }

        function moveNode(sourceNode, targetPath, sourceArray, sourceIndex) {
            // 1. Resolve Target Path
            let actualTargetPath = targetPath;
            if (!actualTargetPath) {
                // Return to original parent logic if empty? 
                // Currently user clears it to return. 
                // But if they type "root" or empty?
                // Logic says: "Vymažte pro návrat na původní místo" -> checks original_path
                if (sourceNode.original_path) {
                    const parts = sourceNode.original_path.split('.');
                    if (parts.length > 1) {
                        parts.pop();
                        actualTargetPath = parts.join('.');
                    } else {
                        // Original was root
                        actualTargetPath = '';
                    }
                }
            }

            // 2. Helper Cyclic Check
            function isDescendant(parent, child) {
                if (!parent.children) return false;
                for (let c of parent.children) {
                    if (c === child || isDescendant(c, child)) return true;
                }
                return false;
            }

            // 3. Find Target Node
            let targetNode = null;
            if (actualTargetPath) {
                targetNode = findNodeByPath(rootData, actualTargetPath);
            } else {
                targetNode = { children: rootData }; // Virtual root
            }

            if (targetNode) {
                // Cycle Check
                if (isDescendant(sourceNode, targetNode)) {
                    showStatus('Chyba: Nelze přesunout složku do jejího vlastního potomka.', 'red');
                    return;
                }

                // 4. Perform Move
                if (sourceIndex > -1) {
                    sourceArray.splice(sourceIndex, 1);
                    if (!targetNode.children) targetNode.children = [];

                    // If virtual root, targetNode.children IS rootData
                    // But we created a new object {children: rootData}. 
                    // Pushing to targetNode.children pushes to rootData. Correct.

                    targetNode.children.push(sourceNode);

                    render();
                    selectNode(actualTargetPath ? `${actualTargetPath}.${sourceNode.key}` : sourceNode.key);
                }
            } else {
                showStatus(`Cílová složka '${actualTargetPath}' nebyla nalezena.`, 'red');
            }
        }

        // --- MANIPULATION (ADD/DELETE) ---

        function addNode(parentKey, type) {
            const parentNode = parentKey ? findNodeByPath(rootData, parentKey) : { children: rootData }; // Mock parent for root
            if (!parentNode) return;

            const children = parentKey ? (parentNode.children || (parentNode.children = [])) : rootData;
            const newKey = prompt("Zadejte unikátní klíč pro nový uzel:", "new_node");
            if (!newKey) return;

            // Simple duplicate check in siblings
            if (children.find(c => c.key === newKey)) {
                alert("Klíč již existuje v této úrovni.");
                return;
            }

            const newNode = {
                key: newKey,
                description: "Nový uzel",
                order: (children.length + 1) * 10,
                skip: false,
                new_only: false,
                original_path: parentKey ? `${parentKey}.${newKey}` : newKey
            };

            if (type === 'leaf') {
                newNode.widget = 'input';
                newNode.width = 12;
            } else {
                newNode.children = [];
            }

            children.push(newNode);
            render();
            selectNode(newNode.original_path); // Might need recalcing path if original_path logic is strict
        }

        function deleteNode(path) {
            if (!confirm(`Opravdu smazat uzel ${path}?`)) return;

            const parts = path.split('.');
            const key = parts.pop();
            const parentPath = parts.join('.');

            let parentArray = rootData;
            if (parentPath) {
                const p = findNodeByPath(rootData, parentPath);
                if (p) parentArray = p.children;
            }

            const idx = parentArray.findIndex(n => n.key === key);
            if (idx !== -1) {
                parentArray.splice(idx, 1);
                render();
                document.getElementById('detail-panel').innerHTML = ''; // Clear detail
            }
        }

        function findNodeByPath(nodes, path) { return findNodeByPathRecursive(nodes, '', path); }
        function findNodeByPathRecursive(nodes, prefix, targetPath) {
            for (let node of nodes) {
                const currentPath = prefix ? `${prefix}.${node.key}` : node.key;
                if (currentPath === targetPath) return node;
                if (node.children) {
                    const found = findNodeByPathRecursive(node.children, currentPath, targetPath);
                    if (found) return found;
                }
            }
            return null;
        }

        // --- RENDERERS ---

        function render() {
            const tbody = document.getElementById('tbody');
            tbody.innerHTML = '';

            function traverse(nodes, level = 0, parentKey = '', hidden = false, parentArray = null) {
                nodes.sort((a, b) => (a.order || 0) - (b.order || 0));

                if (parentArray === null) {
                    const btn = document.createElement('div');
                    btn.className = 'mb-2 p-2';
                    btn.innerHTML = `<button onclick="addNode('', 'leaf')" class="bg-green-100 hover:bg-green-200 text-green-700 px-2 py-1 rounded text-xs mr-2">+ Root Leaf</button>
                              <button onclick="addNode('', 'folder')" class="bg-yellow-100 hover:bg-yellow-200 text-yellow-700 px-2 py-1 rounded text-xs">+ Root Folder</button>`;
                    tbody.appendChild(btn);
                }

                nodes.forEach(node => {
                    const fullKey = parentKey ? `${parentKey}.${node.key}` : node.key;
                    const isLeaf = !node.children || node.children.length === 0;
                    const padding = level * 16 + 12; // Compact padding

                    const isSelected = fullKey === selectedPath;

                    const tr = document.createElement('tr');
                    tr.className = `node-row transition-colors cursor-pointer border-b border-gray-50 ${isSelected ? 'selected' : ''}`;
                    if (node.skip) tr.classList.add('text-gray-400', 'bg-gray-50/50');
                    if (hidden) tr.style.display = 'none';

                    tr.onclick = () => selectNode(fullKey);

                    // 1. Tree Column
                    const tdTree = document.createElement('td');
                    tdTree.className = 'py-1.5 pr-2 text-sm font-mono align-middle whitespace-nowrap';

                    const hasChildren = node.children && node.children.length > 0;
                    const icon = hasChildren
                        ? (node._collapsed
                            ? '<svg class="w-3 h-3 mr-1.5 text-yellow-600 inline transform -rotate-90" fill="currentColor" viewBox="0 0 20 20"><path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/></svg>'
                            : '<svg class="w-3 h-3 mr-1.5 text-yellow-500 inline" fill="currentColor" viewBox="0 0 20 20"><path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/></svg>')
                        : '<span class="w-3 h-3 mr-1.5 inline-block border-l border-b border-gray-300 transform -translate-y-1"></span>';

                    const indent = `<div style="padding-left: ${padding}px" class="flex items-center">`;
                    const labelSpan = `<span onclick="${hasChildren ? `toggleCollapse('${fullKey}')` : ''}" class="${!isLeaf ? 'font-bold' : ''} hover:text-indigo-600">${node.key}</span>`;

                    tdTree.innerHTML = `${indent}<span onclick="${hasChildren ? `toggleCollapse('${fullKey}')` : ''}" class="cursor-pointer p-1">${icon}</span>${labelSpan}</div>`;
                    tr.appendChild(tdTree);

                    // 2. Skip
                    const tdSkip = document.createElement('td');
                    tdSkip.className = 'py-1 px-1 text-center';
                    const chkSkip = document.createElement('input');
                    chkSkip.type = 'checkbox';
                    chkSkip.checked = node.skip || false;
                    chkSkip.className = 'rounded text-indigo-600 focus:ring-indigo-500 h-3 w-3 border-gray-300';
                    chkSkip.onclick = (e) => e.stopPropagation();
                    chkSkip.onchange = (e) => { node.skip = e.target.checked; render(); renderDetail(fullKey); };
                    tdSkip.appendChild(chkSkip);
                    tr.appendChild(tdSkip);

                    // 3. New Only
                    const tdNew = document.createElement('td');
                    tdNew.className = 'py-1 px-1 text-center';
                    const chkNew = document.createElement('input');
                    chkNew.type = 'checkbox';
                    chkNew.checked = node.new_only || false;
                    chkNew.className = 'rounded text-green-600 focus:ring-green-500 h-3 w-3 border-gray-300';
                    chkNew.disabled = node.skip;
                    chkNew.onclick = (e) => e.stopPropagation();
                    chkNew.onchange = (e) => { node.new_only = e.target.checked; render(); }; // Re-render to update detail if open?
                    tdNew.appendChild(chkNew);
                    tr.appendChild(tdNew);

                    // 4. Description (Editable in tree per user request)
                    const tdDesc = document.createElement('td');
                    tdDesc.className = 'py-1 px-2';
                    const inpDesc = document.createElement('input');
                    inpDesc.type = 'text';
                    inpDesc.value = node.description || '';
                    inpDesc.disabled = node.skip;
                    inpDesc.className = 'w-full bg-transparent text-xs border-0 border-b border-transparent focus:border-indigo-500 focus:ring-0 px-0 py-0.5 placeholder-gray-300';
                    inpDesc.placeholder = 'Popis...';
                    inpDesc.onclick = (e) => e.stopPropagation();
                    inpDesc.onchange = (e) => {
                        node.description = e.target.value;
                        if (selectedPath === fullKey) renderDetail(fullKey); // Sync detail
                    };
                    tdDesc.appendChild(inpDesc);
                    tr.appendChild(tdDesc);

                    // 5. Order
                    const tdOrder = document.createElement('td');
                    tdOrder.className = 'py-1 px-1 text-center';
                    const inpOrder = document.createElement('input');
                    inpOrder.type = 'number';
                    inpOrder.value = node.order || 0;
                    inpOrder.disabled = node.skip;
                    inpOrder.className = 'w-12 text-xs border border-gray-200 rounded text-center py-0.5 focus:ring-indigo-500 focus:border-indigo-500';
                    inpOrder.onclick = (e) => e.stopPropagation();
                    inpOrder.onchange = (e) => { node.order = parseInt(e.target.value) || 0; render(); };
                    tdOrder.appendChild(inpOrder);
                    tr.appendChild(tdOrder);

                    // 6. Width
                    const tdWidth = document.createElement('td');
                    tdWidth.className = 'py-1 px-1 text-center';
                    if (isLeaf) {
                        const inpWidth = document.createElement('input');
                        inpWidth.type = 'number';
                        inpWidth.min = 1;
                        inpWidth.max = 12;
                        inpWidth.value = node.width || 12;
                        inpWidth.disabled = node.skip;
                        inpWidth.className = 'w-10 text-xs border border-gray-200 rounded text-center py-0.5 focus:ring-indigo-500 focus:border-indigo-500';
                        inpWidth.onclick = (e) => e.stopPropagation();
                        inpWidth.onchange = (e) => { node.width = parseInt(e.target.value) || 12; renderDetail(fullKey); };
                        tdWidth.appendChild(inpWidth);
                    }
                    tr.appendChild(tdWidth);

                    tbody.appendChild(tr);

                    if (node.children) {
                        traverse(node.children, level + 1, fullKey, hidden || node.skip || node._collapsed, node.children);
                    }
                });
            }
            traverse(rootData, 0, '', false, rootData);
        }

        function renderDetail(path) {
            const panel = document.getElementById('detail-panel');
            if (!path) return;

            const node = findNodeByPath(rootData, path);
            if (!node) return;

            const isFolder = Array.isArray(node.children);

            let html = `
                <div class="space-y-4">
                    <div class="pb-2 border-b border-gray-100 flex justify-between items-start">
                        <div>
                             <span class="text-xs font-mono text-gray-400 block">${node.original_path || '(root)'}</span>
                             ${node.id
                    ? `<input type="text" class="text-xs font-medium bg-purple-50 text-purple-800 font-mono mt-1 border-purple-200 rounded px-1" value="${node.id}" onchange="updateNodeProp('${path}', 'id', this.value)" title="ID Node">`
                    : `<button onclick="updateNodeProp('${path}', 'id', prompt('Assign ID:'))" class="text-xs text-blue-500 hover:underline">+ Assign ID</button>`}
                        </div>
                        <div class="flex flex-col gap-1 items-end">
                              <button onclick="deleteNode('${path}')" class="text-red-500 hover:text-red-700 text-xs px-2">Smazat</button>
                              ${isFolder ? `
                                <div class="flex gap-1 mt-1">
                                     <button onclick="addNode('${path}', 'leaf')" class="bg-green-50 hover:bg-green-100 text-green-700 text-[10px] px-1.5 py-0.5 rounded border border-green-200">+ Child</button>
                                     <button onclick="addNode('${path}', 'folder')" class="bg-yellow-50 hover:bg-yellow-100 text-yellow-700 text-[10px] px-1.5 py-0.5 rounded border border-yellow-200">+ Folder</button>
                                </div>
                              ` : ''}
                        </div>
                    </div>
                    
                    <div>
                         <label class="block text-xs font-medium text-gray-700 mb-1">Klíč (Key)</label>
                         <input type="text" value="${node.key}" onchange="updateNodeKey('${path}', this.value)" class="w-full text-sm font-bold border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>

                    <!-- Basic Info -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">Popis (Label/Description)</label>
                        <textarea id="detail-desc" rows="2" class="w-full text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500" ${node.skip ? 'disabled' : ''}>${node.description || ''}</textarea>
                    </div>
            `;

            // Common fields for everything now (user requested editable everywhere)
            // Specially Widget type
            html += `
                <div class="grid grid-cols-1 gap-4">
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">Widget / Typ</label>
                        <select id="detail-widget" class="w-full text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500" ${node.skip ? 'disabled' : ''}>
                            <option value="input" ${node.widget === 'input' ? 'selected' : ''}>Input (Text)</option>
                            <option value="selection" ${node.widget === 'selection' ? 'selected' : ''}>Selection (Dropdown)</option>
                            <option value="file" ${node.widget === 'file' ? 'selected' : ''}>File (Upload)</option>
                            <option value="textarea" ${node.widget === 'textarea' ? 'selected' : ''}>Textarea (Long Text)</option>
                            <option value="markdown" ${node.widget === 'markdown' ? 'selected' : ''}>Markdown (Rich Text)</option>
                            <option value="group" ${!node.widget && isFolder ? 'selected' : ''}>Group / Folder</option>
                        </select>
                    </div>
                </div>
            `;

            // Conditional Fields
            if (node.widget === 'selection') {
                html += `
                    <div class="mt-2">
                        <label class="block text-xs font-medium text-gray-700 mb-1">Číselník</label>
                        <input type="text" list="enum-list" id="detail-ciselnik" value="${node.ciselnik || ''}" placeholder="Vyberte nebo zadejte" class="w-full text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                        <datalist id="enum-list">
                            ${Object.keys(enums).map(k => `<option value="${k}">${k}</option>`).join('')}
                        </datalist>
                    </div>`;
            }

            if (node.widget === 'file') {
                html += `
                     <div class="mt-2 flex items-center">
                         <input type="checkbox" id="detail-multiple" ${node.multiple ? 'checked' : ''} class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                         <label for="detail-multiple" class="ml-2 block text-xs font-medium text-gray-700">Povolit více souborů (Multiple)</label>
                     </div>
                     <div class="mt-2">
                         <label class="block text-xs font-medium text-gray-700 mb-1">Label pro nahrávání</label>
                         <input type="text" id="detail-label" value="${node.label || ''}" placeholder="Např. Nahrát přílohy" class="w-full text-sm border-gray-300 rounded shadow-sm">
                     </div>
                 `;
            }

            if (node.widget === 'markdown') {
                html += `
                      <div class="mt-2">
                          <label class="block text-xs font-medium text-gray-700 mb-1">Markdown Content</label>
                          <textarea id="detail-content" rows="6" class="w-full text-sm font-mono border-gray-300 rounded shadow-sm bg-gray-50">${node.content || ''}</textarea>
                          <p class="text-[10px] text-gray-400">Podporuje **bold**, *italic*, [link](#), - list</p>
                      </div>
                  `;
            }

            if (node.widget === 'textarea') {
                html += `
                    <div class="mt-2">
                        <label class="block text-xs font-medium text-gray-700 mb-1">Počet řádků (Rows)</label>
                        <input type="number" id="detail-rows" value="${node.rows || 3}" class="w-full text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    </div>`;
            }

            // Reparenting available for everyone
            html += `
                    <div class="mt-3 pt-3 border-t border-gray-100">
                        <label class="block text-xs font-medium text-gray-700 mb-1">Manuální Rodič (Reparenting)</label>
                        <div class="flex gap-2">
                             <input type="text" id="detail-parent" value="${node.manual_parent || ''}" placeholder="path.to.new.parent" class="flex-1 text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500" ${node.skip ? 'disabled' : ''}>
                             <button onclick="applyReparent()" class="bg-gray-100 hover:bg-gray-200 border border-gray-300 text-gray-600 px-3 py-1 rounded text-xs font-medium">Přesunout</button>
                        </div>
                    </div>

                    <!-- Default Value -->
                    <div class="mt-2">
                         <label class="block text-xs font-medium text-gray-700 mb-1">Defaultní hodnota</label>
                         <input type="text" id="detail-default" value="${node.default_value || ''}" class="w-full text-sm border-gray-300 rounded shadow-sm focus:border-indigo-500 focus:ring-indigo-500" ${node.skip ? 'disabled' : ''}>
                    </div>

                    <!-- Editable Excel Meta Info -->
                    <div class="bg-blue-50 p-3 rounded border border-blue-100 text-xs text-blue-800 space-y-2 mt-4">
                        <strong class="block text-blue-900 mb-1 border-b border-blue-200 pb-1">Excel Metadata (Editable)</strong>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-[10px] text-blue-600">Dat. typ</label>
                                <input type="text" value="${node.dat_typ || ''}" onchange="updateNodeProp('${path}', 'dat_typ', this.value)" class="w-full text-xs border-blue-200 rounded p-1">
                            </div>
                             <div>
                                <label class="block text-[10px] text-blue-600">Délka</label>
                                <input type="text" value="${node.delka || ''}" onchange="updateNodeProp('${path}', 'delka', this.value)" class="w-full text-xs border-blue-200 rounded p-1">
                            </div>
                             <div>
                                <label class="block text-[10px] text-blue-600">Mandatory</label>
                                <input type="text" value="${node.mandatory || ''}" onchange="updateNodeProp('${path}', 'mandatory', this.value)" class="w-full text-xs border-blue-200 rounded p-1">
                            </div>
                             <div>
                                <label class="block text-[10px] text-blue-600">P / N / Z</label>
                                <div class="flex gap-1">
                                    <input type="text" placeholder="P" value="${node.p || ''}" onchange="updateNodeProp('${path}', 'p', this.value)" class="w-1/3 text-xs border-blue-200 rounded p-1">
                                    <input type="text" placeholder="N" value="${node.n || ''}" onchange="updateNodeProp('${path}', 'n', this.value)" class="w-1/3 text-xs border-blue-200 rounded p-1">
                                    <input type="text" placeholder="Z" value="${node.z || ''}" onchange="updateNodeProp('${path}', 'z', this.value)" class="w-1/3 text-xs border-blue-200 rounded p-1">
                                </div>
                            </div>
                        </div>
                        <div>
                             <label class="block text-[10px] text-blue-600">Vysvětlivky</label>
                             <textarea rows="2" onchange="updateNodeProp('${path}', 'vysvetlivky', this.value)" class="w-full text-xs border-blue-200 rounded p-1">${node.vysvetlivky || ''}</textarea>
                        </div>
                    </div>
                `;

            /* Removed isLeaf check block - merged into above */

            html += `</div>`;
            panel.innerHTML = html;

            // Attach listeners
            document.getElementById('detail-desc').onchange = (e) => { node.description = e.target.value; render(); };
            document.getElementById('detail-default').onchange = (e) => { node.default_value = e.target.value; };

            const w = document.getElementById('detail-widget');
            if (w) {
                w.onchange = (e) => {
                    node.widget = e.target.value;
                    // Clear props if switching types to avoid junk? Maybe allow keeping.
                    renderDetail(path); // Re-render to show type-specific fields
                };
            }

            // Bind Specifics
            if (document.getElementById('detail-ciselnik')) {
                document.getElementById('detail-ciselnik').onchange = (e) => node.ciselnik = e.target.value;
            }
            if (document.getElementById('detail-multiple')) {
                document.getElementById('detail-multiple').onchange = (e) => node.multiple = e.target.checked;
            }
            if (document.getElementById('detail-label')) {
                document.getElementById('detail-label').onchange = (e) => node.label = e.target.value;
            }
            if (document.getElementById('detail-content')) {
                document.getElementById('detail-content').onchange = (e) => node.content = e.target.value;
            }
            if (document.getElementById('detail-rows')) {
                document.getElementById('detail-rows').onchange = (e) => node.rows = parseInt(e.target.value);
            }
        }

        // Helper for single prop updates
        function updateNodeProp(path, prop, value) {
            const node = findNodeByPath(rootData, path);
            if (node) {
                node[prop] = value;
                if (prop === 'id') renderDetail(path);
            }
        }

        function updateNodeKey(path, newKey) {
            const node = findNodeByPath(rootData, path);
            if (node && newKey && newKey !== node.key) {
                // Check for sibling key collision
                const parts = path.split('.');
                const oldKey = parts.pop();
                const parentPath = parts.join('.');

                let parentArray = rootData;
                if (parentPath) {
                    const p = findNodeByPath(rootData, parentPath);
                    if (p) parentArray = p.children;
                }

                if (parentArray && parentArray.some(n => n.key === newKey && n !== node)) {
                    showStatus(`Chyba: Klíč '${newKey}' již existuje na této úrovni.`, 'red');
                    return;
                }

                node.key = newKey;
                // Update original_path if it exists
                if (node.original_path) {
                    const opParts = node.original_path.split('.');
                    opParts[opParts.length - 1] = newKey;
                    node.original_path = opParts.join('.');
                }
                render();
                selectNode(node.original_path || newKey); // Re-select with potentially new path
            }
        }

        function applyReparent() {
            if (!selectedPath) return;
            const node = findNodeByPath(rootData, selectedPath);
            const input = document.getElementById('detail-parent');
            if (node && input) {
                node.manual_parent = input.value;
                // Find source array... traverse? Or just pass rootData and let moveNode find it?
                // moveNode needs the source array to splice from.
                // We can find parent by path parts.

                // Little tricky: we need the ARRAY the node is currently in.
                // Helper to find parent node of a node
                function findParentArray(nodes, targetNode) {
                    for (let n of nodes) {
                        if (n === targetNode) return nodes;
                        if (n.children) {
                            const arr = findParentArray(n.children, targetNode);
                            if (arr) return arr;
                        }
                    }
                    return null;
                }

                const sourceArray = findParentArray(rootData, node);
                if (sourceArray) {
                    const sourceIndex = sourceArray.indexOf(node);
                    if (sourceIndex > -1) {
                        moveNode(node, node.manual_parent, sourceArray, sourceIndex);
                        render();
                        // Try to re-select
                        setTimeout(() => {
                            // We don't know the exact new path easily without recalc, but we can try to select by key in the tree logic if we enhanced selectNode. 
                            // For now, just keep the tree open.
                        }, 50);
                    }
                }
            }
        }

        function exportData() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(rootData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "regzec_form.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function showStatus(msg, color) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.className = `px-3 py-1 rounded text-xs bg-${color}-100 text-${color}-800 block`;
            el.classList.remove('hidden');
            setTimeout(() => el.classList.add('hidden'), 5000);
        }

        function renumberNodes() {
            if (!confirm("Opravdu chcete přečíslovat všechny položky? (Pořadí zůstane zachováno, hodnoty budou 10, 20, 30...)")) return;

            function processLevel(nodes) {
                // Sort by current order first to respect visual order
                nodes.sort((a, b) => (a.order || 0) - (b.order || 0));

                nodes.forEach((node, index) => {
                    node.order = (index + 1) * 10;
                    if (node.children && node.children.length > 0) {
                        processLevel(node.children);
                    }
                });
            }

            processLevel(rootData);
            render();
            showStatus("Přečíslování dokončeno.", "blue");
        }

        window.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>

</html>